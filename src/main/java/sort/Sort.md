###정렬

정렬을 다 까먹어서.. 한번 다시 정리한다..\
왜 정렬 하면 맨날 버블만 생각날까. \
너무 당황스럽다. \
복습좀 해야겠다!

---
#### 참고 : 안전 정렬과 불안전 정렬
 정렬에서의 안정성이란 `정렬되지 않은 상태에서 같은 키값을 가진 원소의 순서가 보장여부` 를 말한다.\
한마디로 `b C B A c` 와 같은 문자열이 있고, 이를 대소문자 무시하고 정렬하면 \
안전 정렬은   `A b B C c` 의 결과를 얻고 \
불안전 정렬은  `A B b c C` 의 결과를 얻거나, 어떤 결과를 얻을지 알수 없는 정렬이다.

---
> O(n<sup>2</sup>)
1. 버블 정렬 
   - 두개씩 바꿔가면서, 비교하여 정렬. 
   - 구현은 생략한다
   - 안전 정렬
    
2. 선택 정렬
    - 리스트(서브리스트) 에서 최소값을 `선택` 해서 제일 앞으로 위치
    - 구현은 생략한다
    - 불안전 정

3. 삽입 정렬
    - N번쨰 원소를 1 ~ (N-1) 까지 비교해 적절한 위치에 `삽입` 한다.
    - 로직은 다음과 같다.
      - 1 ~ (N-1)은 정렬 되어 있다.
      - 자기보다 작은숫자(오름, 내림차순에 따라 달라짐)가 나올떄까지 N-1 부터 1까지 찾는다.
      - 찾으면 해당 위치에 삽입한다. (삽입하기 위에 찾는 과정에서 기존 배열을 한칸씩 이동한다.)
    - 간단하게 구현 한다.
    - 안전 정렬
   

---
>O(N * logN)
1. 병합 정렬(머지 소트)
   - 원소 개수가 1 또는 0이 될때까지 절반씩(?) 자르고, 그 역순으로 합치면서 정렬한다.
   - 분할정복
   - 병합 정렬은 같은 정렬순서를 가진 값에 대해서 기존 리스트의 정렬 순서를 보장한다.
   - 언제나 N log N 을 보장하기 떄문에 
   - 레코드를 LinkedList로 구성하면, 링크 인덱스만 병경되어, 제자리 정렬(in-place sorting)이 가능하다.
     - 구현 예정
     - mid와 mid 관련 Logic이 복잡할듯?
   - 배열로 구현한다.
   - 안전 정렬
   
2. 퀵 정렬(퀵 소트)
   - 방법은 다음과 같다.
      - 리스트의 한 요소(pivot) 기본으로 피벗보다 작은 요소는 왼쪾으로 옮기고, 큰 요소는 오른쪽으로 옮긴다.
      - 좌측 리스트도 피벗을 다시정해 정렬하고, 오른쪽 리스트도 피벗을 다시정해 정렬한다ㅣ.
      - 이를 반복한다.
   - 다른 N logN 의 알고리즘 보다 속도가 빠르다.
   - 정렬된 리스트에는 n^2 의 시간복잡도를 가진다(Worst Case)
   - 
